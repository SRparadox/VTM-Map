<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTM Territory Map - Santa Cruz</title>
    <!-- 
        VTM Territory Map - 3D Visualization Interface
        
        This page provides an interactive 3D visualization of city maps where users can
        assign vampire clan territories to buildings and areas. It uses Three.js for
        3D rendering and provides a dark, atmospheric interface suitable for
        Vampire: The Masquerade campaigns.
        
        Features:
        - 3D city visualization with buildings, roads, and landmarks
        - Clan selection and territory assignment
        - Interactive camera controls (zoom, pan, rotate)
        - Real-time territory visualization with clan colors
        - Atmospheric lighting for vampire theme
    -->
    <style>
        /* 
         * CSS Styles for VTM Territory Map Interface
         * Dark theme appropriate for vampire content
         */
        
        /* Reset and base styles */
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;  /* Dark background */
            color: #fff;          /* Light text */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;     /* Prevent scrollbars on 3D canvas */
        }
        
        /* Main container for the entire application */
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* 3D canvas element - fills entire viewport */
        #canvas {
            display: block;
        }
        
        /* User interface panel - positioned over the 3D scene */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;                    /* Ensure UI appears above 3D scene */
            background: rgba(0, 0, 0, 0.8);  /* Semi-transparent dark background */
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(5px);      /* Blur effect for modern browsers */
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .clan-button {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            color: white;
            transition: opacity 0.3s;
        }
        
        .clan-button:hover {
            opacity: 0.8;
        }
        
        .territory-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 12px;
        }
        
        h1 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #8B0000;
        }
        
        h2 {
            margin: 15px 0 5px 0;
            font-size: 14px;
            color: #CC6666;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <h1>üßõ VTM Territory Map</h1>
            <h2>Santa Cruz, CA</h2>
            
            <div>
                <h2>Select Clan:</h2>
                <button class="clan-button" style="background-color: #1a365d;" onclick="selectClan('ventrue')">Ventrue</button>
                <button class="clan-button" style="background-color: #c53030;" onclick="selectClan('toreador')">Toreador</button>
                <button class="clan-button" style="background-color: #d69e2e;" onclick="selectClan('brujah')">Brujah</button>
                <button class="clan-button" style="background-color: #553c9a;" onclick="selectClan('malkavian')">Malkavian</button>
                <button class="clan-button" style="background-color: #2d3748;" onclick="selectClan('nosferatu')">Nosferatu</button>
                <button class="clan-button" style="background-color: #38a169;" onclick="selectClan('gangrel')">Gangrel</button>
                <button class="clan-button" style="background-color: #805ad5;" onclick="selectClan('tremere')">Tremere</button>
            </div>
            
            <div class="territory-info">
                <strong>Controls:</strong><br>
                üéÆ <strong>Movement:</strong><br>
                ‚Ä¢ W/A/S/D - Move forward/left/back/right<br>
                ‚Ä¢ Space - Move up<br>
                ‚Ä¢ Shift - Move down (or hold for fast mode)<br>
                <br>
                üñ±Ô∏è <strong>Mouse:</strong><br>
                ‚Ä¢ Middle-click - Enable mouse look<br>
                ‚Ä¢ Mouse wheel - Zoom in/out<br>
                ‚Ä¢ Left click - Assign clan territory<br>
                ‚Ä¢ Right click - Remove territory<br>
                ‚Ä¢ ESC - Exit mouse look mode<br>
                <br>
                <strong>Territory Assignment:</strong><br>
                1. Select a clan above<br>
                2. Click buildings to assign<br>
                3. Buildings will change color
            </div>
        </div>
        
        <div id="status">
            Middle-click to enable mouse look, WASD to move
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /**
         * VTM Map 3D Visualization System
         * 
         * This JavaScript application creates an interactive 3D map visualization
         * for Vampire: The Masquerade territory assignment. It uses Three.js for
         * 3D rendering and provides tools for clan territory management.
         * 
         * Key Features:
         * - 3D city rendering with buildings, roads, and landmarks
         * - Interactive clan selection and territory assignment
         * - Mouse controls for camera movement and interaction
         * - Real-time territory visualization with clan colors
         * - Atmospheric lighting effects for vampire theme
         * 
         * Controls:
         * - Left click: Assign selected clan to building
         * - Right click: Remove clan assignment from building
         * - Mouse drag: Pan camera around the scene
         * - Mouse wheel: Zoom in/out
         * 
         * @author VTM Map Project
         * @version 1.0.0
         */
        
        /**
         * Main VTM Map visualization class
         * Manages the 3D scene, user interactions, and territory assignments
         */
        class VTMMap {
            /**
             * Initialize the VTM Map visualization
             * Sets up Three.js scene, camera, renderer, and event handlers
             */
            constructor() {
                // Core Three.js objects
                this.scene = null;              // 3D scene container
                this.camera = null;             // Camera for viewing the scene
                this.renderer = null;           // WebGL renderer
                
                // Interaction management
                this.selectedClan = null;       // Currently selected vampire clan
                this.territories = new Map();   // Map of assigned territories
                this.buildings = [];            // Array of building meshes
                this.raycaster = new THREE.Raycaster(); // For mouse picking
                this.mouse = new THREE.Vector2();       // Mouse coordinates
                
                // Clan color mapping (hex values converted to Three.js color format)
                this.clanColors = {
                    'ventrue': 0x1a365d,    // Deep blue
                    'toreador': 0xc53030,   // Deep red  
                    'brujah': 0xd69e2e,     // Golden yellow
                    'malkavian': 0x553c9a,  // Purple
                    'nosferatu': 0x2d3748,  // Dark gray
                    'gangrel': 0x38a169,    // Forest green
                    'tremere': 0x805ad5     // Mystical purple
                };
                
                // Initialize the application
                this.init();
                this.createSampleCity();
                this.animate();
            }
            
            init() {
                const container = document.getElementById('canvas');
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);
                this.scene.fog = new THREE.Fog(0x0a0a0a, 500, 2000);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    1, 
                    3000
                );
                this.camera.position.set(0, 200, 300);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: container,
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Improved lighting system - much brighter and more visible
                // Strong ambient light for overall scene illumination
                const ambientLight = new THREE.AmbientLight(0x606060, 0.8);
                this.scene.add(ambientLight);
                
                // Main directional light (sunlight/moonlight)
                const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
                mainLight.position.set(100, 300, 100);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 1000;
                mainLight.shadow.camera.left = -500;
                mainLight.shadow.camera.right = 500;
                mainLight.shadow.camera.top = 500;
                mainLight.shadow.camera.bottom = -500;
                this.scene.add(mainLight);
                
                // Secondary light from opposite direction for better visibility
                const fillLight = new THREE.DirectionalLight(0x8888ff, 0.6);
                fillLight.position.set(-100, 200, -100);
                this.scene.add(fillLight);
                
                // Point lights for atmospheric effect
                const streetLight1 = new THREE.PointLight(0xffaa44, 0.8, 200);
                streetLight1.position.set(50, 30, 50);
                this.scene.add(streetLight1);
                
                const streetLight2 = new THREE.PointLight(0xffaa44, 0.8, 200);
                streetLight2.position.set(-50, 30, -50);
                this.scene.add(streetLight2);
                
                // Event listeners for improved controls
                window.addEventListener('resize', () => this.onWindowResize(), false);
                container.addEventListener('click', (event) => this.onMouseClick(event), false);
                container.addEventListener('mousemove', (event) => this.onMouseMove(event), false);
                container.addEventListener('contextmenu', (event) => event.preventDefault(), false);
                
                // Mouse controls
                this.setupAdvancedControls();
                
                document.getElementById('status').textContent = 'Santa Cruz 3D map loaded - Middle-click for mouse look, WASD to move!';
            }
            
            /**
             * Setup advanced movement controls (WASD + mouse look)
             * Provides first-person style navigation similar to gaming controls
             */
            setupAdvancedControls() {
                // Movement state tracking
                this.moveState = {
                    forward: false,  // W key
                    backward: false, // S key  
                    left: false,     // A key
                    right: false,    // D key
                    up: false,       // Space key
                    down: false      // Shift key
                };
                
                // Mouse look state
                this.mouseState = {
                    isLocked: false,
                    sensitivity: 0.002,
                    yaw: 0,    // Horizontal rotation
                    pitch: 0,  // Vertical rotation
                    maxPitch: Math.PI / 3  // Limit vertical look
                };
                
                // Movement speed settings
                this.movementSpeed = 2.0;  // Units per frame
                this.fastMovementSpeed = 4.0;  // With shift held
                
                // Keyboard event handlers
                document.addEventListener('keydown', (event) => this.onKeyDown(event), false);
                document.addEventListener('keyup', (event) => this.onKeyUp(event), false);
                
                // Mouse look handlers
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    if (event.button === 1) { // Middle mouse button for mouse look
                        this.requestPointerLock();
                    }
                });
                
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (this.mouseState.isLocked) {
                        this.updateMouseLook(event);
                    }
                });
                
                // Pointer lock change handler
                document.addEventListener('pointerlockchange', () => {
                    this.mouseState.isLocked = document.pointerLockElement === this.renderer.domElement;
                    if (this.mouseState.isLocked) {
                        document.getElementById('status').textContent = 'Mouse look active - Press ESC to exit';
                    } else {
                        document.getElementById('status').textContent = 'Middle-click to enable mouse look, WASD to move';
                    }
                });
                
                // Mouse wheel for zoom
                this.renderer.domElement.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const zoomSpeed = 0.1;
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.camera.quaternion);
                    
                    if (event.deltaY > 0) {
                        // Zoom out
                        this.camera.position.add(forward.multiplyScalar(-zoomSpeed * 10));
                    } else {
                        // Zoom in
                        this.camera.position.add(forward.multiplyScalar(zoomSpeed * 10));
                    }
                });
            }
            
            /**
             * Handle keyboard key press events
             */
            onKeyDown(event) {
                switch (event.code) {
                    case 'KeyW':
                        this.moveState.forward = true;
                        break;
                    case 'KeyS':
                        this.moveState.backward = true;
                        break;
                    case 'KeyA':
                        this.moveState.left = true;
                        break;
                    case 'KeyD':
                        this.moveState.right = true;
                        break;
                    case 'Space':
                        event.preventDefault();
                        this.moveState.up = true;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        this.moveState.down = true;
                        break;
                    case 'Escape':
                        if (this.mouseState.isLocked) {
                            document.exitPointerLock();
                        }
                        break;
                }
            }
            
            /**
             * Handle keyboard key release events
             */
            onKeyUp(event) {
                switch (event.code) {
                    case 'KeyW':
                        this.moveState.forward = false;
                        break;
                    case 'KeyS':
                        this.moveState.backward = false;
                        break;
                    case 'KeyA':
                        this.moveState.left = false;
                        break;
                    case 'KeyD':
                        this.moveState.right = false;
                        break;
                    case 'Space':
                        this.moveState.up = false;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        this.moveState.down = false;
                        break;
                }
            }
            
            /**
             * Request pointer lock for mouse look functionality
             */
            requestPointerLock() {
                this.renderer.domElement.requestPointerLock();
            }
            
            /**
             * Update camera rotation based on mouse movement
             */
            updateMouseLook(event) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                // Update yaw (horizontal rotation)
                this.mouseState.yaw -= movementX * this.mouseState.sensitivity;
                
                // Update pitch (vertical rotation) with limits
                this.mouseState.pitch -= movementY * this.mouseState.sensitivity;
                this.mouseState.pitch = Math.max(
                    -this.mouseState.maxPitch, 
                    Math.min(this.mouseState.maxPitch, this.mouseState.pitch)
                );
                
                // Apply rotation to camera
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.mouseState.yaw;
                this.camera.rotation.x = this.mouseState.pitch;
            }
            
            /**
             * Update camera position based on movement state
             */
            updateMovement() {
                if (!this.camera) return;
                
                // Determine current movement speed
                const speed = this.moveState.down ? this.fastMovementSpeed : this.movementSpeed;
                
                // Calculate movement vectors
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                const up = new THREE.Vector3(0, 1, 0);
                
                // Apply camera rotation to movement vectors
                forward.applyQuaternion(this.camera.quaternion);
                right.applyQuaternion(this.camera.quaternion);
                
                // Apply movement based on input state
                if (this.moveState.forward) {
                    this.camera.position.add(forward.clone().multiplyScalar(speed));
                }
                if (this.moveState.backward) {
                    this.camera.position.add(forward.clone().multiplyScalar(-speed));
                }
                if (this.moveState.left) {
                    this.camera.position.add(right.clone().multiplyScalar(-speed));
                }
                if (this.moveState.right) {
                    this.camera.position.add(right.clone().multiplyScalar(speed));
                }
                if (this.moveState.up) {
                    this.camera.position.add(up.clone().multiplyScalar(speed));
                }
                if (this.moveState.down && !this.moveState.forward && !this.moveState.backward && !this.moveState.left && !this.moveState.right) {
                    // Only move down if shift is held without other movement
                    this.camera.position.add(up.clone().multiplyScalar(-speed));
                }
                
                // Prevent camera from going below ground level
                this.camera.position.y = Math.max(2, this.camera.position.y);
            }
            
            createSampleCity() {
                // Create a brighter ground plane
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x3a3a3a  // Lighter gray for better visibility
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Create sample buildings in a grid pattern
                for (let i = 0; i < 50; i++) {
                    const building = this.createBuilding(
                        (Math.random() - 0.5) * 800,
                        (Math.random() - 0.5) * 800,
                        Math.random() * 30 + 10
                    );
                    this.buildings.push(building);
                    this.scene.add(building);
                }
                
                // Create some streets
                this.createStreets();
                
                // Add some water (representing Santa Cruz coastline)
                this.createWater();
            }
            
            createBuilding(x, z, height) {
                const width = Math.random() * 20 + 10;
                const depth = Math.random() * 20 + 10;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x888888,  // Lighter default color for better visibility
                    transparent: true,
                    opacity: 0.9
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                building.userData = { 
                    type: 'building', 
                    clan: null,
                    originalColor: 0x888888  // Updated to match the new lighter color
                };
                
                return building;
            }
            
            createStreets() {
                // Main streets with better visibility
                for (let i = -400; i <= 400; i += 100) {
                    const streetGeometry = new THREE.PlaneGeometry(800, 8);
                    const streetMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 }); // Lighter roads
                    const street = new THREE.Mesh(streetGeometry, streetMaterial);
                    street.rotation.x = -Math.PI / 2;
                    street.position.set(i, 0.1, 0);
                    this.scene.add(street);
                    
                    const street2 = new THREE.Mesh(streetGeometry, streetMaterial);
                    street2.rotation.x = -Math.PI / 2;
                    street2.rotation.z = Math.PI / 2;
                    street2.position.set(0, 0.1, i);
                    this.scene.add(street2);
                }
            }
            
            createWater() {
                const waterGeometry = new THREE.PlaneGeometry(1000, 200);
                const waterMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x001166,
                    transparent: true,
                    opacity: 0.7
                });
                const water = new THREE.Mesh(waterGeometry, waterMaterial);
                water.rotation.x = -Math.PI / 2;
                water.position.set(0, 0.5, -450);
                this.scene.add(water);
            }
            
            onMouseClick(event) {
                if (!this.selectedClan) {
                    document.getElementById('status').textContent = 'Please select a clan first!';
                    return;
                }
                
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.buildings);
                
                if (intersects.length > 0) {
                    const building = intersects[0].object;
                    
                    if (event.button === 2) { // Right click - remove territory
                        this.removeTerritoryFromBuilding(building);
                    } else { // Left click - assign territory
                        this.assignTerritoryToBuilding(building, this.selectedClan);
                    }
                }
            }
            
            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            
            assignTerritoryToBuilding(building, clan) {
                building.userData.clan = clan;
                building.material.color.setHex(this.clanColors[clan]);
                building.material.opacity = 0.9;
                
                const territoryKey = `${building.position.x}_${building.position.z}`;
                this.territories.set(territoryKey, clan);
                
                document.getElementById('status').textContent = 
                    `Building assigned to ${clan.charAt(0).toUpperCase() + clan.slice(1)}`;
            }
            
            removeTerritoryFromBuilding(building) {
                building.userData.clan = null;
                building.material.color.setHex(building.userData.originalColor);
                building.material.opacity = 0.8;
                
                const territoryKey = `${building.position.x}_${building.position.z}`;
                this.territories.delete(territoryKey);
                
                document.getElementById('status').textContent = 'Territory removed from building';
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update movement based on input state
                this.updateMovement();
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Global functions
        function selectClan(clan) {
            window.vtmMap.selectedClan = clan;
            document.getElementById('status').textContent = 
                `${clan.charAt(0).toUpperCase() + clan.slice(1)} clan selected - Click buildings to assign territory`;
            
            // Update button styles
            document.querySelectorAll('.clan-button').forEach(btn => {
                btn.style.border = '2px solid transparent';
            });
            event.target.style.border = '2px solid white';
        }
        
        // Initialize the application
        window.addEventListener('load', () => {
            window.vtmMap = new VTMMap();
        });
        
        // Disable right-click context menu
        document.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>
